"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.data = void 0;
const builder_1 = require("../classes/builder");
const utils_1 = require("../classes/utils");
function fillText(ctx, mytext, x, y, width, height, align, vAlign) {
    const size = Number(ctx.font.match(/[\d]{1,5}px/g)[0].replace('px', ''));
    if (width <= 0 || height <= 0 || size <= 0) {
        return;
    }
    const xEnd = x + width;
    const yEnd = y + height;
    let txtY = y + height / 2 + size / 2;
    let textanchor;
    if (align === 'right') {
        textanchor = xEnd;
        ctx.textAlign = 'right';
    }
    else if (align === 'left') {
        textanchor = x;
        ctx.textAlign = 'left';
    }
    else {
        textanchor = x + width / 2;
        ctx.textAlign = 'center';
    }
    let textarray = [];
    let temptextarray = mytext.split('\n');
    temptextarray.forEach(txtt => {
        let textwidth = ctx.measureText(txtt).width;
        if (textwidth <= width) {
            textarray.push(txtt);
        }
        else {
            let temptext = txtt;
            let linelen = width;
            let textlen;
            let textpixlen;
            let texttoprint;
            textwidth = ctx.measureText(temptext).width;
            while (textwidth > linelen) {
                textlen = 0;
                textpixlen = 0;
                texttoprint = '';
                while (textpixlen < linelen) {
                    textlen++;
                    texttoprint = temptext.substr(0, textlen);
                    textpixlen = ctx.measureText(temptext.substr(0, textlen)).width;
                }
                textlen--;
                texttoprint = texttoprint.substr(0, textlen);
                const backup = textlen;
                if (temptext.substr(textlen, 1) != ' ') {
                    while (temptext.substr(textlen, 1) != ' ' && textlen != 0) {
                        textlen--;
                    }
                    if (textlen == 0) {
                        textlen = backup;
                    }
                    texttoprint = temptext.substr(0, textlen);
                }
                texttoprint = texttoprint;
                temptext = temptext.substr(textlen);
                textwidth = ctx.measureText(temptext).width;
                textarray.push(texttoprint);
            }
            if (textwidth > 0) {
                textarray.push(temptext);
            }
        }
    });
    const charHeight = (0, utils_1.getTextHeight)(ctx, mytext, ctx.font);
    const vheight = charHeight * (textarray.length - 1);
    const negoffset = vheight / 2;
    let debugY = y;
    if (vAlign === 'top') {
        txtY = y + size;
    }
    else if (vAlign === 'bottom') {
        txtY = yEnd - vheight;
        debugY = yEnd;
    }
    else {
        debugY = y + height / 2;
        txtY -= negoffset;
    }
    textarray.forEach(txtline => {
        txtline = txtline.trim();
        ctx.fillText(txtline, textanchor, txtY);
        txtY += charHeight;
    });
}
exports.data = {
    data: new builder_1.FunctionBuilder()
        .setName('drawText')
        .setValue('description', 'Draws a text in the canvas.')
        .setValue('use', '$drawText[text;x;y;width;height;align?(right|left|center);vAlign?(top|bottom|middle)]')
        .setValue('returns', 'Void'),
    code: async (d) => {
        let r = d.unpack(d);
        if (!r.inside)
            return utils_1.Utils.Warn('Invalid inside provided in:', d.func);
        if (r.splits.length < 3)
            return utils_1.Utils.Warn('Invalid fields provided in:', d.func);
        let [text, x, y, width, height, align = 'left', vAlign = 'top'] = r.splits;
        if (!utils_1.Utils.isNumber(x) || !utils_1.Utils.isNumber(y) || !utils_1.Utils.isNumber(width) || !utils_1.Utils.isNumber(height))
            return utils_1.Utils.Warn('Some numer is invalid in:', d.func);
        if (!d._.Canvas?.ctx)
            return utils_1.Utils.Warn('Not canvas found, create one first using $createCanvas, in:', d.func);
        fillText(d._.Canvas.ctx, text.unescape(), Number(x), Number(y), Number(width), Number(height), align, vAlign);
        return {
            code: d.code.resolve(`${d.func}[${r.inside}]`, '')
        };
    }
};

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.symbols = exports.getTextHeight = exports.Utils = void 0;
const tslib_1 = require("tslib");
const safe_1 = tslib_1.__importDefault(require("colors/safe"));
const hjson_1 = tslib_1.__importDefault(require("hjson"));
const equal = (str) => str.split('==')[0] == str.split('==')[1];
const not_equal = (str) => str.split('!=')[0] != str.split('!=')[1];
const major = (str) => Number(str.split('>')[0]) > Number(str.split('>')[1]);
const minor = (str) => Number(str.split('<')[0]) < Number(str.split('<')[1]);
const m_e = (str) => Number(str.split('>=')[0]) >= Number(str.split('>=')[1]);
const mi_e = (str) => Number(str.split('<=')[0]) <= Number(str.split('<=')[1]);
exports.Utils = {
    Warn(error, data) {
        console.log(`${safe_1.default.yellow("[ WARNING ]")} ${safe_1.default.red(error)} ${safe_1.default.cyan(data)}`);
    },
    isNumber(num) {
        return num.replace(/^-?\d*\.?\d+$/g, '') ? false : true;
    },
    booleanify(str) {
        let r;
        str = str.toLowerCase();
        if (str === 'yes' || str === 'true')
            r = true;
        if (str === 'no' || str === 'false')
            r = false;
        return r || true;
    },
    condition(condition) {
        try {
            let ands = condition.split('&&');
            let results = [];
            for (const and of ands) {
                if (and.includes('||'))
                    results = or(and);
                else if (and.includes('=='))
                    results.push(equal(and));
                else if (and.includes('!='))
                    results.push(not_equal(and));
                else if (and.includes('>='))
                    results.push(m_e(and));
                else if (and.includes('<='))
                    results.push(mi_e(and));
                else if (and.includes('>'))
                    results.push(major(and));
                else if (and.includes('<'))
                    results.push(minor(and));
                else
                    results.push(and);
            }
            if (results === null)
                return null;
            return condition.includes('||') ? results : eval(results.join('&&'));
        }
        catch {
            return null;
        }
    },
    loadObject(json) {
        try {
            let r = hjson_1.default.parse(json);
            return typeof r === 'object' ? r : null;
        }
        catch {
            return null;
        }
    },
    isValidHex(str) {
        if (!str)
            return false;
        return /^([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(str.replace(/(#)/g, ''));
    },
    molde(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }
};
function or(str) {
    try {
        let ors = str.split('||');
        let results = [];
        for (const or of ors) {
            if (or.includes('=='))
                results.push(equal(or));
            else if (or.includes('!='))
                results.push(not_equal(or));
            else if (or.includes('>='))
                results.push(m_e(or));
            else if (or.includes('<='))
                results.push(mi_e(or));
            else if (or.includes('>'))
                results.push(major(or));
            else if (or.includes('<'))
                results.push(minor(or));
            else
                results.push(or);
        }
        return results.some(Boolean);
    }
    catch {
        return null;
    }
}
function getTextHeight(ctx, text, style) {
    const previousTextBaseline = ctx.textBaseline;
    const previousFont = ctx.font;
    ctx.textBaseline = 'bottom';
    ctx.font = style;
    const { actualBoundingBoxAscent: height1, actualBoundingBoxDescent: height2 } = ctx.measureText(text);
    ctx.textBaseline = previousTextBaseline;
    ctx.font = previousFont;
    return height1 + height2 + 1.7;
}
exports.getTextHeight = getTextHeight;
exports.symbols = ["K", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "O", "N", "D", "UD", "UD", "DD", "TD", "QaD", "QiD", "SxD", "SpD", "OD", "ND", "V", "UV", "DV", "TV", "QaV", "QiV", "SxV", "SpV", "OV", "NV", "DT", "UDT", "DDT", "TDT", "QaDT", "QiDT", "SxDT", "SpDT", "ODT", "NDT", "DQa", "UDQa", "DDQa", "TDQa", "QaDQa", "QiDQa", "SxDQa", "SpDQa", "ODQa", "NDQa", "DQi", "UDQi", "DDQi", "TDQi", "QaDQi", "QiDQi", "SxDQi", "SpDQi", "ODQi", "NDQi", "DSx", "UDSx", "DDSx", "TDSx", "QaDSx", "QiDSx", "SxDSx", "SpDSx", "ODSx", "NDSx", "DSp", "UDSp", "DDSp", "TDSp", "QaDSp", "QiDSp", "SxDSp", "SpDSp", "ODSp", "NDSp", "DO", "UDO", "DDO", "TDO", "QaDO", "QiDO", "SxDO", "SpDO", "ODO", "NDO", "DN", "UDN", "DDN", "TDN", "QaDN", "QiDN", "SxDN", "SpDN", "ODN", "NDN", "C", "UC"];

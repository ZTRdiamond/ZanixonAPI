"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Database = void 0;
const tslib_1 = require("tslib");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const fs_1 = require("fs");
const path_1 = require("path");
const tiny_typed_emitter_1 = require("tiny-typed-emitter");
class Database extends tiny_typed_emitter_1.TypedEmitter {
    path;
    tables;
    constructor(options) {
        super();
        this.path = options?.path || '/database';
        this.tables = options?.tables ? options?.tables.concat('main') : ['main'];
    }
    async set(key, value, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.set()');
        let content = this.getTable(table);
        if (!content)
            content = {};
        lodash_1.default.set(content, key, value);
        this.insert(table, content);
    }
    async get(key, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.get()');
        let content = this.getTable(table);
        if (!content)
            return null;
        return lodash_1.default.get(content, key);
    }
    async delete(key, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.delete()');
        let content = this.getTable(table);
        if (!content)
            return;
        lodash_1.default.unset(content, key);
        this.insert(table, content);
    }
    async push(key, value, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.push()');
        let v = await this.get(key, table);
        if (v && !Array.isArray(v))
            throw new SyntaxError('MIDB: Provided key is not an array, reset it to a empty one. In: <Database>.push()');
        if (!v)
            v = [];
        v.push(value);
        this.set(key, v, table);
    }
    async remove(key, value, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.remove()');
        let v = await this.get(key, table);
        if (v && !Array.isArray(v))
            throw new SyntaxError('MIDB: Provided key is not an array, in: <Database>.push()');
        if (!v)
            this.set(key, [], table);
        else {
            v = lodash_1.default.without(v, value);
            this.set(key, v, table);
        }
    }
    async add(key, value, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.remove()');
        if (isNaN(value))
            throw new SyntaxError('MIDB: Provided value is not a number in <Database>.add()');
        let v = await this.get(key, table);
        if (v && isNaN(v))
            throw new SyntaxError('MIDB: Provided key is not a number, reset it. In: <Database>.add()');
        if (!v)
            v = 0;
        this.set(key, (v + value), table);
    }
    async sub(key, value, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.remove()');
        if (isNaN(value))
            throw new SyntaxError('MIDB: Provided value is not a number in <Database>.add()');
        let v = await this.get(key, table);
        if (v && isNaN(v))
            throw new SyntaxError('MIDB: Provided key is not a number, reset it. In: <Database>.add()');
        if (!v)
            v = 0;
        this.set(key, (v - value), table);
    }
    async has(key, table = 'main') {
        if (!this.isValidTable(table))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.has()');
        let v = await this.get(key, table);
        return v ? true : false;
    }
    async ping() {
        let before = Date.now();
        await this.get('hi');
        return Date.now() - before;
    }
    getTable(name) {
        if (!this.isValidTable(name))
            throw new SyntaxError('MIDB: Invalid table provided in: <Database>.getTable()');
        try {
            let content = (0, fs_1.readFileSync)((0, path_1.join)(process.cwd(), this.path, 'tables', name + '.json'));
            if (!content)
                return null;
            let parsed = JSON.parse(content.toString());
            return parsed;
        }
        catch {
            return null;
        }
    }
    insert(name, data) {
        if (!(0, fs_1.existsSync)((0, path_1.join)(process.cwd(), this.path, 'tables', name))) {
            (0, fs_1.writeFileSync)((0, path_1.join)(process.cwd(), this.path, 'tables', name + '.json'), JSON.stringify({}));
        }
        (0, fs_1.writeFileSync)((0, path_1.join)(process.cwd(), this.path, 'tables', name + '.json'), JSON.stringify(data));
    }
    isValidTable(table) {
        return this.tables.includes(table);
    }
    start() {
        if (!(0, fs_1.existsSync)((0, path_1.join)(process.cwd(), this.path))) {
            (0, fs_1.mkdirSync)((0, path_1.join)(process.cwd(), this.path));
        }
        if (!(0, fs_1.existsSync)((0, path_1.join)(process.cwd(), this.path, 'tables'))) {
            (0, fs_1.mkdirSync)((0, path_1.join)(process.cwd(), this.path, 'tables'));
        }
        this.emit('ready', this);
    }
}
exports.Database = Database;
exports.default = { Database, version: require('../package.json').version };
